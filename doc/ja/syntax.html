<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN"
    "http://www.w3.org/TR/html4/strict.dtd">
<html lang="ja">
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta http-equiv="Content-Script-Type" content="text/javascript">
<meta http-equiv="Content-Style-Type" content="text/css">
<meta name="author" content="magicant">
<meta name="description" content="Yash で使えるコマンドの文法について">
<title>Yash マニュアル: コマンドの文法</title>
<link rel="Contents" href="index.html" title="目次">
<link rel="Prev" href="invocation.html" title="シェルの起動">
<link rel="Next" href="params.html" title="パラメータと変数">

<div class="breadcrumb"><a rel="Up" href="index.html">目次</a> ></div>
<h1>コマンドの文法</h1>

<p>シェルはコマンドを一行ずつ読み込んで解釈し、実行します。一行に複数のコマンドがある場合は、それら全てを解釈してから実行します。一つのコマンドが複数行にまたがっている場合は、そのコマンドを解釈し終えるのに必要なだけ後続の行が読み込まれます。コマンドを正しく解釈できない場合は、文法エラーとなり、コマンドは実行されません。
<p>非対話モードで文法エラーが発生した時は、シェルはコマンドの読み込みを中止するため、それ以降のコマンドは一切読み込まれません。

<h2 id="tokens">トークンの解析と予約語</h2>
<p>コマンドは、いくつかのトークンによって構成されます。<dfn>トークン</dfn>とは、シェルの文法における一つ一つの単語のことを言います。トークンは原則として空白 (空白文字またはタブ文字) によって区切られます。ただしコマンド置換などに含まれる空白はトークンの区切りとは見なしません。
<p>以下の記号は、シェルの文法において特別な意味を持っています。これらの記号も多くの場合他の通常のトークンの区切りとなります。
<div class="tokenlist"><code>;</code> <code>&amp;</code> <code>|</code> <code>&lt;</code> <code>></code> <code>(</code> <code>)</code></div>
<p>以下の記号はトークンの区切りにはなりませんが、文法上特別な意味を持っています。
<div class="tokenlist"><code>$</code> <code>`</code> <code>\</code> <code>"</code> <code>'</code> <code>*</code> <code>?</code> <code>[</code> <code>#</code> <code>~</code> <code>=</code> <code>%</code></div>
<p>以下のトークンは特定の場面において<dfn>予約語</dfn>と見なされます。予約語は複合コマンドなどを構成する一部となります。
<div class="tokenlist"><code>!</code> <code>{</code> <code>}</code> <code>case</code> <code>do</code> <code>done</code> <code>elif</code> <code>else</code> <code>esac</code> <code>fi</code> <code>for</code> <code>if</code> <code>in</code> <code>then</code> <code>until</code> <code>while</code></div>
<p>これらのトークンは以下の場面において予約語となります。
<ul>
<li>それがコマンドの最初のトークンのとき
<li>それが他の予約語 (<code>case</code>, <code>for</code>, <code>in</code> を除く) の直後のトークンのとき
<li><a class="TODO">Case コマンド</a>のマッチング対象のトークンの直後の <code>in</code>
<li><a class="TODO">For コマンド</a>の変数名の直後の <code>in</code> または <code>do</code>
</ul>
<p>トークンが <code>#</code> で始まる場合、その <code>#</code> から行末までは<dfn>コメント</dfn>と見なされます。コマンドの解釈においてコメントは完全に無視されます。
<!-- These tokens are not keywords now: function, select, [[, ]] -->

<h2 id="quotes">クォート</h2>
<p>空白や上記の区切り記号・予約語などを通常の文字と同じように扱うには、適切な引用符でクォートする必要があります。引用符として、バックスラッシュ・一重引用符・二重引用符の三種類が使えます。
<ul>
<li><p>バックスラッシュ (<code>\</code>) は直後の一文字をクォートします。バックスラッシュそのものは単語から取り除かれます。
<p>例外として、バックスラッシュの直後に改行がある場合、それは改行をクォートしているのではなく、<dfn>行の連結</dfn>と見なされます。バックスラッシュと改行が削除され、バックスラッシュがあった行とその次の行が元々一つの行であったかのように扱われます。
<li><p>二つの一重引用符 (<code>'</code>) で囲んだ部分では、全ての文字は通常の文字と同じように扱われます。改行を一重引用符で囲むこともできます。ただし、一重引用符を一重引用符で囲むことはできません。
<li><p>二つの二重引用符 (<code>"</code>) で囲んだ部分も一重引用符で囲んだ部分と同様にクォートされますが、いくつか例外があります。二重引用符で囲んだ部分では、パラメータ展開・コマンド置換・数式展開が通常通り解釈されます。またバックスラッシュは <code>$</code>, <code>`</code>, <code>"</code>, <code>\</code> の直前にある場合および行の連結を行う場合にのみ引用符として扱われ、それ以外のバックスラッシュは通常の文字と同様に扱われます。
</ul>

<h2 id="aliases">エイリアス</h2>
<p>コマンドを構成する各トークンは、それが予め登録されたエイリアスの名前に一致するかどうか調べられます。一致するものがあれば、そのトークンはそのエイリアスの内容に置き換えられて、その後コマンドの解析が続けられます。これを<dfn>エイリアス置換</dfn>といいます。
<p>エイリアスの名前に引用符を含めることはできないので、引用符を含むトークンはエイリアス置換されません。また、予約語もエイリアス置換されません。
<p>エイリアスには通常のエイリアスとグローバルエイリアスの二種類があります。<dfn>通常のエイリアス</dfn>は、コマンドの最初のトークンにのみ一致します。<dfn>グローバルエイリアス</dfn>はコマンド内の全てのトークンが一致の対象です。グローバルエイリアスは POSIX 規格にはない拡張機能です。
<p>エイリアス置換の結果がさらに別のエイリアスに一致して置換される場合もあります。しかし、同じエイリアスに再び一致することはありません。

<h2 id="simple">単純コマンド</h2>
<p>最初のトークンが予約語でないコマンドは、<dfn>単純コマンド</dfn>です。単純コマンドは<a class="TODO">コマンドの検索と実行</a>のしかたに従って実行されます。
<p>単純コマンドの初めのトークンが <var>名前</var>=<var>値</var> の形式になっている場合は、それは変数代入と見なされます。ただしここでの<var>名前</var>は、一文字以上のアルファベット・数字または下線 (<code>_</code>) で、かつ最初が数字でないものです。変数代入ではない最初のトークンはコマンドの名前と解釈されます。それ以降のトークンは (たとえ変数代入の形式をしていたとしても) コマンドの引数と解釈されます。
<p>全てのトークンが変数代入の形式ならば、変数の代入だけが行われ、コマンドは実行されません。

<h2 id="pipelines">パイプライン</h2>
<p><dfn>パイプライン</dfn>は、一つ以上のコマンド (<a href="#simple">単純コマンド</a>、<a href="#compound">複合コマンド</a>、または<a href="#funcdef">関数定義</a>) を記号 <code>|</code> で繋いだものです。
<p>パイプラインの実行は、パイプラインに含まれる各コマンドをそれぞれ独立した<a class="TODO">サブシェル</a>で同時に実行することで行われます。この時、各コマンドの標準出力は次のコマンドの標準入力にパイプで受け渡されます。最初のコマンドの標準入力と最後のコマンドの標準出力は元のままです。最後のコマンドの終了ステータスがパイプラインの終了ステータスになります。
<p>パイプラインの先頭には、記号 <code>!</code> を付けることができます。この場合、パイプラインの終了ステータスが<em>逆転</em>します。つまり、最後のコマンドの終了ステータスが 0 のときはパイプラインの終了ステータスは 1 になり、それ以外の場合は 0 になります。
<p>注: 最後のコマンドの終了ステータスがパイプラインの終了ステータスになるため、パイプラインの実行が終了するのは少なくとも最後のコマンドの実行が終了した後です。しかしそのとき他のコマンドの実行が終了しているとは限りません。また、最後のコマンドの実行が終了したらすぐにパイプラインの実行が終了するとも限りません。(シェルは、他のコマンドの実行が終わるまで待つ場合があります)
<p>注: POSIX 規格では、パイプライン内の各コマンドはサブシェルではなく現在の<a class="TODO">コマンド実行環境</a>で実行してもよいことになっています。

<h2 id="and-or">And/or リスト</h2>
<p><dfn>And/or リスト</dfn>は一つ以上の<a href="#pipelines">パイプライン</a>を記号 <code>&amp;&amp;</code> または <code>||</code> で繋いだものです。
<p>And/or リストの実行は、and/or リストに含まれる各パイプラインを条件付きで実行することで行われます。最初のパイプラインは常に実行されます。それ以降のパイプラインの実行は、前のパイプラインの終了ステータスによります。
<ul>
<li>二つのパイプラインが <code>&amp;&amp;</code> で繋がれている場合、前のパイプラインの終了ステータスが 0 ならば後のパイプラインが実行されます。
<li>二つのパイプラインが <code>||</code> で繋がれている場合、前のパイプラインの終了ステータスが 0 でなければ後のパイプラインが実行されます。
<li>それ以外の場合は、and/or リストの実行はそこで終了し、それ以降のパイプラインは実行されません。
</ul>
<p>最後に実行したパイプラインの終了ステータスが and/or リストの終了ステータスになります。
<p>構文上、and/or リストの直後には原則として記号 <code>;</code> または <code>&amp;</code> が必要です (<a href="#async">コマンドの区切りと非同期コマンド</a>参照)。

<h2 id="async">コマンドの区切りと非同期コマンド</h2>
<p>シェルが受け取るコマンドの全体は、<a href="#and-or">and/or リスト</a>を <code>;</code> または <code>&amp;</code> で区切ったものです。行末または <code>)</code> の直前にある <code>;</code> は省略できますが、それ以外の場合は and/or リストの直後には必ず <code>;</code> と <code>&amp;</code> のどちらかが必要です。
<p>And/or リストの直後に <code>;</code> がある場合は、その and/or リストは同期的に実行されます。すなわち、その and/or リストの実行が終わった後に次の and/or リストが実行されます。And/or リストの直後に <code>&amp;</code> がある場合は、その and/or リストは非同期的に実行されます。すなわち、その and/or リストの実行を開始した後、終了を待たずに、すぐさま次の and/or リストの実行に移ります。非同期な and/or リストは常に<a class="TODO">サブシェル</a>で実行されます。

<h2 id="compound">複合コマンド</h2>
<p>複合コマンドは、より複雑なプログラムの制御を行う手段を提供します。

<h3 id="grouping">グルーピング</h3>
<p>グルーピングを使うと、複数のコマンドを一つのコマンドとして扱うことができます。
<dl>
<dt>通常のグルーピングの構文
<dd><code>{ <var>コマンド</var>...; }</code>
<dt>サブシェルのグルーピングの構文
<dd><code>(<var>コマンド</var>...)</code>
</dl>
<p><code>{</code> と <code>}</code> は予約語なので、他のコマンドのトークンとくっつけて書いてはいけません。一方 <code>(</code> と <code>)</code> は特殊な区切り記号と見なされるので、他のトークンとくっつけて書くことができます。
<p>通常のグルーピング構文 (<code>{</code> と <code>}</code> で囲む) では、コマンドは (他のコマンドと同様に) 現在の<a class="TODO">コマンド実行環境</a>で実行されます。サブシェルのグルーピング構文 (<code>(</code> と <code>)</code> で囲む) では、括弧内のコマンドは新たなサブシェルで実行されます。
<h3 id="if">If 文</h3>
<p>If 文は条件分岐を行います。分岐の複雑さに応じていくつか構文のバリエーションがあります。
<dl>
<dt>If 文の基本構文
<dd><code>if <var>条件コマンド</var>...; then <var>内容コマンド</var>...; fi
<dt>Else がある場合
<dd><code>if <var>条件コマンド</var>...; then <var>内容コマンド</var>...; else <var>内容コマンド</var>...; fi
<dt>Elif がある場合
<dd><code>if <var>条件コマンド</var>...; then <var>内容コマンド</var>...; elif <var>条件コマンド</var>...; then <var>内容コマンド</var>...; fi
<dt>Elif と else がある場合
<dd><code>if <var>条件コマンド</var>...; then <var>内容コマンド</var>...; elif <var>条件コマンド</var>...; then <var>内容コマンド</var>...; else <var>内容コマンド</var>...; fi
</dl>
<p>If 文の実行では、どの構文の場合でも、<code>if</code> の直後にある<var>条件コマンド</var>がまず実行されます。条件コマンドの終了ステータスが 0 ならば、条件が真であると見なされて <code>then</code> の直後にある<var>内容コマンド</var>が実行され、if 文の実行はそれで終了します。終了ステータスが 0 でなければ、条件が偽であると見なされます。ここで <code>else</code> も <code>elif</code> もなければ、if 文の実行はこれで終わりです。<code>else</code> がある場合は、<code>else</code> の直後の<var>内容コマンド</var>が実行されます。<code>elif</code> がある場合は、<code>elif</code> の直後の<var>条件コマンド</var>が実行され、その終了ステータスが 0 であるかどうか判定されます。その後は先程と同様に条件分岐を行います。
<p><code>elif ...; then ...;</code> は一つの if 文内に複数あっても構いません。
<p>If 文全体の終了ステータスは、実行された内容コマンドの終了ステータスです。内容コマンドが実行されなかった場合 (どの条件も偽で、<code>else</code> がない場合) は 0 です。

<h3 id="while-until">While/until ループ</h3>
<p>While/until ループは単純なループ構文です。
<dl>
<dt>While ループの構文
<dd><code>while <var>コマンド1</var>...; do <var>コマンド2</var>...; done</code>
<dt>Until ループの構文
<dd><code>until <var>コマンド1</var>...; do <var>コマンド2</var>...; done</code>
</dl>
<p>While ループの実行ではまず<var>コマンド1</var>が実行されます。そのコマンドの終了ステータスが 0 ならば、<var>コマンド2</var>が実行されたのち、再び<var>コマンド1</var>の実行に戻ります。この繰り返しは<var>コマンド1</var>の終了ステータスが 0 でなくなるまで続きます。<var>コマンド1</var>の終了ステータスが最初から 0 でないときは、<var>コマンド2</var>は一度も実行されません。
<p>Until ループは、ループを続行する条件が逆になっている以外は while ループと同じです。すなわち、<var>コマンド1</var>の終了ステータスが 0 以外ならば<var>コマンド2</var>が実行されます。
<p>While/until ループ全体の終了ステータスは、最後に実行した<var>コマンド2</var>の終了ステータスです。(<var>コマンド2</var>が一度も実行されなかったときは 0)

<h3 id="for">For ループ</h3>
<p>For ループは指定されたそれぞれの単語について同じコマンドを実行します。
<dl>
<dt>For ループの構文
<dd><code>for <var>変数名</var> in <var>単語</var>...; do <var>コマンド</var>...; done
<dd><code>for <var>変数名</var> do <var>コマンド</var>...; done
</dl>
<p><code>in</code> の直後の<var>単語</var>は一つもなくても構いませんが、<code>do</code> の直前の <code>;</code> (または改行) は必要です。これらの単語トークンは予約語としては認識されませんが、<code>&</code> などの記号を含めるには適切な<a href="#quotes">クォート</a>が必要です。<code>in ...;</code> を省略する場合は、本来は変数名と <code>do</code> の間に <code>;</code> を入れてはいけませんが、非 POSIX 準拠モードでは許容されます。
<p>For ループの実行ではまず<var>単語</var>が<a href="#simple">単純コマンド</a>実行時の単語の展開と同様に展開されます (<code>in ...;</code> がない構文を使用している場合は、<code>in "$@";</code> が省略されているものと見なされます)。続いて、展開で生成されたそれぞれの単語について順番に一度ずつ以下の処理を行います。
<ol>
<li>単語を<var>変数名</var>で指定した変数に代入する
<li><var>コマンド</var>を実行する
</ol>
<p>展開の結果単語が一つも生成されなかった場合は、<var>コマンド</var>は一切実行されません。
<p>For ループ全体の終了ステータスは、最後に実行した<var>コマンド</var>の終了ステータスです。(<var>コマンド</var>が一度も実行されなかったときは 0)

<h3 id="case">Case 文</h3>
<p>Case 文は単語に対してパターンマッチングを行い、その結果に対応するコマンドを実行します。
<dl>
<dt>Case 文の構文
<dd><code>case <var>単語</var> in <var>caseitem</var>... esac</code>
<dt>Caseitem の構文
<dd><code>( <var>パターン</var> ) <var>コマンド</var>... ;;</code>
</dl>
<p><code>case</code> と <code>in</code> の間の単語はちょうど一トークンでなければなりません。この単語トークンは予約語としては認識されませんが、<code>&</code> などの記号を含めるには適切な<a href="#quotes">クォート</a>が必要です。<code>in</code> と <code>esac</code> の間には任意の個数の caseitem を置きます (0 個でもよい)。Caseitem の最初の <code>(</code> は省略できます。また <code>esac</code> の直前の <code>;;</code> も省略できます。
<p>Caseitem の<var>パターン</var>にはトークンを指定します。各トークンを <code>|</code> で区切ることで複数のトークンをパターンとして指定することもできます。
<p>Case 文の実行では、まず<var>単語</var>が<a href="#simple">単純コマンド</a>実行時の単語の展開と同様に展開されます (ただし<a class="TODO">単語分割</a>は行いません)。その後、各 caseitem に対して順に以下の動作を行います。
<ol>
<li><var>パターン</var>トークンを<var>単語</var>と同様に展開し、展開したパターンが展開した単語にマッチするかどうか調べます (<a class="TODO">パターンマッチング記法</a>参照)。<var>パターン</var>として指定されたトークンが複数ある場合はそれら各トークンに対してマッチするかどうか調べます (どれかのパターントークンがマッチしたらそれ以降のパターントークンは展開されません)。
<li>マッチした場合は、直後の<var>コマンド</var>を実行し、それでこの case 文の実行は終了です。マッチしなかった場合は、次の caseitem の処理に移ります。
</ol>
<p>Case 文全体の終了ステータスは、実行した<var>コマンド</var>の終了ステータスです。<var>コマンド</var>が実行されなかった場合 (どのパターンもマッチしなかったか、caseitem が一つもない場合) は、終了ステータスは 0 です。

<h2 id="funcdef">関数定義</h2>
<p>関数定義コマンドは、関数を定義します。
<dl>
<dt>関数定義コマンドの構文
<dd><var>関数名</var> ( ) <var>複合コマンド</var>
</dl>
<p><var>関数名</var>には引用符などの特殊な記号を含めることはできません。
<p>関数定義コマンドを実行すると、指定した<var>関数名</var>の関数が定義されます。関数の内容 (本体) は<var>複合コマンド</var>になります。
<p>関数定義コマンドに対して<a class="TODO">リダイレクト</a>を行うことはできません。関数定義コマンドの最後にあるリダイレクトは、<var>複合コマンド</var>に対するリダイレクトと見なされます。
