<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN"
    "http://www.w3.org/TR/html4/strict.dtd">
<html lang="ja">
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta http-equiv="Content-Script-Type" content="text/javascript">
<meta http-equiv="Content-Style-Type" content="text/css">
<meta name="author" content="magicant">
<meta name="description" content="Yash で使えるコマンドの文法について">
<title>Yash マニュアル: コマンドの文法</title>
<link rel="Contents" href="index.html" title="目次">
<link rel="Prev" href="invocation.html" title="シェルの起動">

<div class="breadcrumb"><a rel="Up" href="index.html">目次</a> ></div>
<h1>コマンドの文法</h1>

<p>シェルはコマンドを一行ずつ読み込んで解釈し、実行します。一行に複数のコマンドがある場合は、それら全てを解釈してから実行します。一つのコマンドが複数行にまたがっている場合は、そのコマンドを解釈し終えるのに必要なだけ後続の行が読み込まれます。コマンドを正しく解釈できない場合は、文法エラーとなり、コマンドは実行されません。
<p>非対話モードで文法エラーが発生した時は、シェルはコマンドの読み込みを中止するため、それ以降のコマンドは一切読み込まれません。

<h2 id="tokens">トークンの解析と予約語</h2>
<p>コマンドは、いくつかのトークンによって構成されます。<dfn>トークン</dfn>とは、シェルの文法における一つ一つの単語のことを言います。トークンは原則として空白 (空白文字またはタブ文字) によって区切られます。ただしコマンド置換などに含まれる空白はトークンの区切りとは見なしません。
<p>以下の記号は、シェルの文法において特別な意味を持っています。これらの記号も多くの場合他の通常のトークンの区切りとなります。
<div class="tokenlist"><code>;</code> <code>&amp;</code> <code>|</code> <code>&lt;</code> <code>></code> <code>(</code> <code>)</code></div>
<p>以下の記号はトークンの区切りにはなりませんが、文法上特別な意味を持っています。
<div class="tokenlist"><code>$</code> <code>`</code> <code>\</code> <code>"</code> <code>'</code> <code>*</code> <code>?</code> <code>[</code> <code>#</code> <code>~</code> <code>=</code> <code>%</code></div>
<p>以下のトークンは特定の場面において<dfn>予約語</dfn>と見なされます。予約語は複合コマンドなどを構成する一部となります。
<div class="tokenlist"><code>!</code> <code>{</code> <code>}</code> <code>case</code> <code>do</code> <code>done</code> <code>elif</code> <code>else</code> <code>esac</code> <code>fi</code> <code>for</code> <code>if</code> <code>in</code> <code>then</code> <code>until</code> <code>while</code></div>
<p>これらのトークンは以下の場面において予約語となります。
<ul>
<li>それがコマンドの最初のトークンのとき
<li>それが他の予約語 (<code>case</code>, <code>for</code>, <code>in</code> を除く) の直後のトークンのとき
<li><a class="TODO">Case コマンド</a>のマッチング対象のトークンの直後の <code>in</code>
<li><a class="TODO">For コマンド</a>の変数名の直後の <code>in</code> または <code>do</code>
</ul>
<p>トークンが <code>#</code> で始まる場合、その <code>#</code> から行末までは<dfn>コメント</dfn>と見なされます。コマンドの解釈においてコメントは完全に無視されます。
<!-- These tokens are not keywords now: function, select, [[, ]] -->

<h2 id="quotes">クォート</h2>
<p>空白や上記の区切り記号・予約語などを通常の文字と同じように扱うには、適切な引用符でクォートする必要があります。引用符として、バックスラッシュ・一重引用符・二重引用符の三種類が使えます。
<ul>
<li><p>バックスラッシュ (<code>\</code>) は直後の一文字をクォートします。バックスラッシュそのものは単語から取り除かれます。
<p>例外として、バックスラッシュの直後に改行がある場合、それは改行をクォートしているのではなく、<dfn>行の連結</dfn>と見なされます。バックスラッシュと改行が削除され、バックスラッシュがあった行とその次の行が元々一つの行であったかのように扱われます。
<li><p>二つの一重引用符 (<code>'</code>) で囲んだ部分では、全ての文字は通常の文字と同じように扱われます。改行を一重引用符で囲むこともできます。ただし、一重引用符を一重引用符で囲むことはできません。
<li><p>二つの二重引用符 (<code>"</code>) で囲んだ部分も一重引用符で囲んだ部分と同様にクォートされますが、いくつか例外があります。二重引用符で囲んだ部分では、パラメータ展開・コマンド置換・数式展開が通常通り解釈されます。またバックスラッシュは <code>$</code>, <code>`</code>, <code>"</code>, <code>\</code> の直前にある場合および行の連結を行う場合にのみ引用符として扱われ、それ以外のバックスラッシュは通常の文字と同様に扱われます。
</ul>

<h2 id="aliases">エイリアス</h2>
<p>コマンドを構成する各トークンは、それが予め登録されたエイリアスの名前に一致するかどうか調べられます。一致するものがあれば、そのトークンはそのエイリアスの内容に置き換えられて、その後コマンドの解析が続けられます。これを<dfn>エイリアス置換</dfn>といいます。
<p>エイリアスの名前に引用符を含めることはできないので、引用符を含むトークンはエイリアス置換されません。また、予約語もエイリアス置換されません。
<p>エイリアスには通常のエイリアスとグローバルエイリアスの二種類があります。<dfn>通常のエイリアス</dfn>は、コマンドの最初のトークンにのみ一致します。<dfn>グローバルエイリアス</dfn>はコマンド内の全てのトークンが一致の対象です。グローバルエイリアスは POSIX 規格にはない拡張機能です。
<p>エイリアス置換の結果がさらに別のエイリアスに一致して置換される場合もあります。しかし、同じエイリアスに再び一致することはありません。

<h2 id="simple">単純コマンド</h2>
<p>最初のトークンが予約語でないコマンドは、<dfn>単純コマンド</dfn>です。単純コマンドは<a class="TODO">コマンドの検索と実行</a>のしかたに従って実行されます。
<p>単純コマンドの初めのトークンが <var>名前</var>=<var>値</var> の形式になっている場合は、それは変数代入と見なされます。ただしここでの<var>名前</var>は、一文字以上のアルファベット・数字または下線 (<code>_</code>) で、かつ最初が数字でないものです。変数代入ではない最初のトークンはコマンドの名前と解釈されます。それ以降のトークンは (たとえ変数代入の形式をしていたとしても) コマンドの引数と解釈されます。
<p>全てのトークンが変数代入の形式ならば、変数の代入だけが行われ、コマンドは実行されません。

<h2 id="pipelines">パイプライン</h2>
<p><dfn>パイプライン</dfn>は、一つ以上のコマンドを記号 <code>|</code> で繋いだものです。
<p>パイプラインの実行は、パイプラインに含まれる各コマンドをそれぞれ独立した<a class="TODO">サブシェル</a>で同時に実行することで行われます。この時、各コマンドの標準出力は次のコマンドの標準入力にパイプで受け渡されます。最初のコマンドの標準入力と最後のコマンドの標準出力は元のままです。パイプライン内のコマンドの実行が終わると、パイプラインの実行が終わります。最後のコマンドの終了ステータスがパイプラインの終了ステータスになります。
<p>パイプラインの先頭には、記号 <code>!</code> を付けることができます。この場合、パイプラインの終了ステータスが<em>逆転</em>します。つまり、最後のコマンドの終了ステータスが 0 のときはパイプラインの終了ステータスは 1 になり、それ以外の場合は 0 になります。
<p>注: 最後のコマンドの終了ステータスがパイプラインの終了ステータスになるため、パイプラインの実行が終了するのは少なくとも最後のコマンドの実行が終了した後です。しかしそのとき他のコマンドの実行が終了しているとは限りません。また、最後のコマンドの実行が終了したらすぐにパイプラインの実行が終了するとも限りません。(シェルは、他のコマンドの実行が終わるまで待つ場合があります)
<p>注: POSIX 規格では、パイプライン内の各コマンドはサブシェルではなく現在の<a class="TODO">コマンド実行環境</a>で実行してもよいことになっています。

<h2 id="and-or">And/or リスト</h2>
<p><dfn>And/or リスト</dfn>は一つ以上の<a href="#pipelines">パイプライン</a>を記号 <code>&amp;&amp;</code> または <code>||</code> で繋いだものです。
<p>And/or リストの実行は、and/or リストに含まれる各パイプラインを条件付きで実行することで行われます。最初のパイプラインは常に実行されます。それ以降のパイプラインの実行は、前のパイプラインの終了ステータスによります。
<ul>
<li>二つのパイプラインが <code>&amp;&amp;</code> で繋がれている場合、前のパイプラインの終了ステータスが 0 ならば後のパイプラインが実行されます。
<li>二つのパイプラインが <code>||</code> で繋がれている場合、前のパイプラインの終了ステータスが 0 でなければ後のパイプラインが実行されます。
<li>それ以外の場合は、and/or リストの実行はそこで終了し、それ以降のパイプラインは実行されません。
</ul>
<p>最後に実行したパイプラインの終了ステータスが and/or リストの終了ステータスになります。

<h2 id="compound">複合コマンド</h2>
<p>複合コマンドは、より複雑なプログラムの制御を行う手段を提供します。

<h3 id="grouping">グルーピング</h3>
<p>グルーピングを使うと、複数のコマンドを一つのコマンドとして扱うことができます。
<dl>
<dt>通常のグルーピングの構文
<dd><code>{ <var>コマンド</var>...; }</code>
<dt>サブシェルのグルーピングの構文
<dd><code>(<var>コマンド</var>...)</code>
</dl>
<p><code>{</code> と <code>}</code> は予約語なので、他のコマンドのトークンとくっつけて書いてはいけません。一方 <code>(</code> と <code>)</code> は特殊な区切り記号と見なされるので、他のトークンとくっつけて書くことができます。
<p>通常のグルーピング構文 (<code>{</code> と <code>}</code> で囲む) では、コマンドは (他のコマンドと同様に) 現在の<a class="TODO">コマンド実行環境</a>で実行されます。サブシェルのグルーピング構文 (<code>(</code> と <code>)</code> で囲む) では、括弧内のコマンドは新たなサブシェルで実行されます。
<h3 id="if">If 文</h3>
<p>If 文は条件分岐を行います。分岐の複雑さに応じていくつか構文のバリエーションがあります。
<dl>
<dt>If 文の基本構文
<dd><code>if <var>コマンド</var>...; then <var>コマンド</var>...; fi
<dt>Else がある場合
<dd><code>if <var>コマンド</var>...; then <var>コマンド</var>...; else <var>コマンド</var>...; fi
<dt>Elif がある場合
<dd><code>if <var>コマンド</var>...; then <var>コマンド</var>...; elif <var>コマンド</var>...; then <var>コマンド</var>...; fi
<dt>Elif と else がある場合
<dd><code>if <var>コマンド</var>...; then <var>コマンド</var>...; elif <var>コマンド</var>...; then <var>コマンド</var>...; else <var>コマンド</var>...; fi
</dl>
<p>どの構文の場合でも、<code>if</code> と <code>then</code> の間にあるコマンドがまず実行されます。コマンドの終了ステータスが 0 ならば、条件が真であると見なされて <code>then</code> と <code>fi</code> (あるいは <code>else</code> や <code>elif</code>) の間にあるコマンドが実行され、if 文の実行はそれで終了します。終了ステータスが 0 でなければ、条件が偽であると見なされます。ここで <code>else</code> も <code>elif</code> もなければ、if 文の実行はこれで終わりです。<code>else</code> がある場合は、<code>else</code> と <code>fi</code> の間のコマンドが実行されます。<code>elif</code> がある場合は、<code>elif</code> と </code>then</code> の間にあるコマンドが実行され、その終了ステータスが 0 であるかどうか判定されます。その後は先程と同様に条件分岐を行います。
<p><code>elif</code> と <code>then</code> は一つの if 文内に複数あっても構いません。
<p>If 文の終了ステータスは、どれかの条件が真であった場合はそれに対応して実行された <code>then</code> の後のコマンドの終了ステータスです。どの条件も偽であった場合は、<code>else</code> の後のコマンドの終了ステータスです (<code>else</code> がない場合は 0)。

<h3 id="while-until">While/until ループ</h3>
<h3 id="for">For ループ</h3>
<h3 id="case">Case 文</h3>

<h2 id="async">コマンドの区切りと非同期コマンド</h2>

<h2 id="funcdef">関数定義</h2>
