<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"> 
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>Yash 1.0 説明書</title>

<h1>Yash: yet another shell</h1>

<h2 id=abstract>概要</h2>
<p>このプログラムは C 言語で書いた簡単なコマンドライン端末用シェルである。
<p>これはもともと筆者が学科の課題で作ったプログラムであり、bash などの本格的な
シェルを目指して作ったものではない。機能は少なくシェルスクリプトすら未対応で、
バグも多いと思われる。しかし<q>シェルのソースを見てみたいが bash
のソースは複雑過ぎて読めない</q>というような人にとっては参考になるかもしれない。
<p>不具合の報告や機能改善の提案などは一応受け付けるが、期待しないこと。
<strong>筆者はこのプログラムの動作に関して保証をしないし、
一切責任をとらない。もし使いたいのであればそれを承知の上で
すべて自己責任で使うこと。</strong>
<p>このプログラムは <a href="http://www.gnu.org/licenses/gpl.html">GNU General
Public License</a> (Version 2) の元で自由に再配布・変更などができる。
<!-- というか、GNU Readline ライブラリを使っている以上そうせざるを得ない -->
<p>なお、yash という名前のシェルは他にも存在すると思われるが、特に関係はない。

<h2 id=requirements>要件</h2>
<p>プログラムの中核部分は多くの Unix システムに共通のコードであるが、
付随的機能の実装に Linux 特有の機能を使用している。従って、このシェルを
コンパイル・実行できるのは Linux だけだろう。
<p>このプログラムをコンパイル・実行するには以下のものが必要である:
<ul>
	<li>Linux 2.6.16 以降
	<li>GNU make
	<li>GNU Complier Collection (GCC)
	<li>GNU Readline Library
</ul>

<h2 id=compilation>コンパイル</h2>
<p>yash をコンパイルするには単に make を実行するだけである。
添付の Makefile には install ルールは定義していないので、
もしインストールする場合は /usr/local/bin 辺りに手動でコピーすること。
<p>Readline ライブラリのリンクに関するエラーが出る場合は、Makefile の LDFLAGS
変数の設定で -ltermcap を -lncurses や -lcurses に変えてやってみると
うまくゆくかもしれない。環境によっては -ltermcap
がなくてもうまくいくかもしれない。

<h2 id=firststep>基本的な動作</h2>
<p>プログラムを引数なしで起動すると、端末から一行ずつコマンドを読み取って
実行する対話的モードに入る。コマンドを入力すると、コマンドが実行され、
コマンドが終了すれば次のコマンドの入力を待つ。exit/logout コマンドを実行するか
EOL (Ctrl-D) を入力すると、(未了のジョブがなければ) シェルを終了する。
<p>シェルがログインシェルとして起動される (-l オプション付きで起動するか、
起動時のプログラム名が <code>-</code> で始まる) と、--noprofile オプションが
ない限り、対話的モードに入る前に初期化ファイル ~/.yash_profile を読み取って、
ファイルの中に書いてあるコマンドを一行ずつ実行する。ログインシェルでない場合、
--norc オプションがない限り、対話的モードに入る前に ~/.yashrc
を読み取って同様に実行する。この時実行するファイルは --rcfile
<var>filename</var> オプションで変更できる。
<p>起動時には、これらの他に次のオプションを指定できる:
<dl>
	<dt>--help
	<dd>ヘルプを表示して終了する
	<dt>--version
	<dd>バージョン情報を表示して終了する
	<dt>-l, --login
	<dd>ログインシェルとして実行する。一部のコマンドの動作に影響する。
	<dt>-i, --interactive
	<dd>対話的モードを行う
	<dt>-c <var>command</var>
	<dd>コマンド <var>command</var> を実行して終了する。-i
	オプションより優先する。
</dl>
<p>対話的モードでのコマンドの読み取りは、GNU Readline ライブラリを用いている。
よって、大体 bash と同じように操作できる。option コマンドで履歴ファイルを
指定しておくと、シェルを起動・終了するときに履歴をファイルから読込み・保存する。
<p>対話的モードでは、シェルのプロセスグループ ID はシェル自身のプロセス ID
にリセットされる。シェルが停止・終了するとき、元のプロセスグループ ID に戻る。
<p>対話的モードで毎回入力の読み取りに入る前に、コマンド <code>stty -inlcr -igncr
icrnl icanon echo echoe echok</code> の実行と同様にして端末がリセットされる。

<h2 id=commandsyntax>コマンドの文法</h2>
<p>コマンドの書式も大体 bash と同じであり、以下の記法 (記号) が使える:
<dl>
	<dt><var>n</var>><var>file</var>
	<dd>ファイルディスクリプタ <var>n</var> に、ファイル <var>file</var>
	に書き込むためのリダイレクトを生成する。<var>n</var>
	を省略すると標準出力をリダイレクトする。
	<dt><var>n</var>&lt;<var>file</var>
	<dd>ファイルディスクリプタ <var>n</var> に、ファイル <var>file</var>
	から読み込むためのリダイレクトを生成する。<var>n</var>
	を省略すると標準入力をリダイレクトする。
	<dt><var>n</var>&lt;><var>file</var>
	<dd>ファイルディスクリプタ <var>n</var> に、ファイル <var>file</var>
	に対する読み書き両用のリダイレクトを生成する。<var>n</var>
	を省略すると標準入力をリダイレクトする。
	<dt><var>n</var>&lt;&amp;<var>m</var>
	<dd>ファイルディスクリプタ <var>m</var> をファイルディスクリプタ
	<var>n</var> にコピーする。<var>n</var> を省略すると標準入力にコピーする。
	<dd><var>m</var> が <code>-</code> ならば、ファイルディスクリプタ
	<var>n</var> を閉じる。<var>n</var> を省略すると標準入力を閉じる。
	<dt><var>n</var>>&amp;<var>m</var>
	<dd>ファイルディスクリプタ <var>m</var> をファイルディスクリプタ
	<var>n</var> にコピーする。<var>n</var> を省略すると標準出力にコピーする。
	<dd><var>m</var> が <code>-</code> ならば、ファイルディスクリプタ
	<var>n</var> を閉じる。<var>n</var> を省略すると標準出力を閉じる。
	<dt><code>|</code>
	<dd>コマンドをパイプラインでつなぐ。
	前のコマンドの出力を次のコマンドに入力する。
	<dt><code>;</code>
	<dd>コマンドを順次実行する。前のコマンドが終わったら次のコマンドを実行する。
	<dt><code>&amp;</code>
	<dd><code>&amp;</code> の前に書かれたコマンドをバックグラウンドで起動する。
	<dt><code>&amp;&amp;</code>
	<dd><code>&amp;&amp;</code> の前に書かれたコマンドの終了ステータスが 0
	の時のみ次のコマンドを実行する
	<dt><code>||</code>
	<dd><code>||</code> の前に書かれたコマンドの終了ステータスが 0
	でない時のみ次のコマンドを実行する
	<dt><code>( ... )</code>
	<dd>括弧内のコマンドをサブシェルで実行する。
	<dt><code>#</code>
	<dd>これ以降をコメントとして無視する
</dl>
<p>リダイレクトの処理はパイプラインよりも後に行う。よって、リダイレクトと
パイプラインの指定が重複するときはリダイレクトがパイプラインを上書きする。
<p>演算子の優先順位は、<code>|</code> が最も高く、続いて <code>&amp;&amp;</code>
と <code>||</code>、そして最も低いのが <code>&amp;</code> と <code>;</code>
である。括弧 <code>( )</code> は演算子の優先順位を変更するのにも使える。
<p><code>|</code> でつないだパイプラインにおいて、最後のコマンドの後にも
<code>|</code> を指定すると (別のいい方をすると、最後の <code>|</code> の後に
コマンドを書かないと)、最後のコマンドの出力が最初のコマンドの入力に繋がれ、
ループ状のパイプラインができる。
<p>括弧 <code>( )</code> で囲まれたコマンドはサブシェル (元のシェルから分岐した
子プロセス) で実行される。
<p>変数は、環境変数のみ利用できる。パラメータ展開やコマンド置換などは
ある程度利用できる。現在、$@ や $? などの特殊なパラメータは未実装である。

<h2 id=parameters>パラメータ</h2>
<p>コマンドライン中の <code>$</code> はパラメータ・変数の展開に使える。
例えば <code>${PWD}</code> と書くとそれを PWD 変数の値に置換する。
また <code>${!VAR}</code> と書くと VAR 変数の値を名前とする変数の値に置換する。
指定した変数が存在しなければ空文字列に置換する。
<p>置換する文字列を操作するために、変数名と <code>}</code> の間に
特殊な書式の文字列を指定することができる。以下の書式が使える。
<dl>
	<dt>${<var>name</var>-<var>word</var>}
	<dd>変数 <var>name</var> が未定義なら、空文字列の代わりに <code>word</code>
	に置換する。
	<dt>${<var>name</var>+<var>word</var>}
	<dd>変数 <var>name</var> が定義済なら、空文字列の代わりに <code>word</code>
	に置換する。
	<dt>${<var>name</var>=<var>word</var>}
	<dd>変数 <var>name</var> が未定義なら、<code>word</code> をその変数に
	代入し、そしてその値に置換する。この記法では特殊パラメータや
	位置パラメータには代入できない。
	<dt>${<var>name</var>?<var>word</var>}
	<dd>変数 <var>name</var> が未定義なら、エラーメッセージとして
	<code>word</code> を出力し、非対話的シェルならそのまま終了する。
	<code>word</code> が空文字列の場合はデフォルトのエラーメッセージを出す。
	<dd>以上の四つの書式では、-, +, =, ? の直前に : を置くと、変数が未定義の
	場合だけでなく変数の内容が空文字列の場合にも同様の各動作を行う。
	<dt>${#<var>name</var>}
	<dd>変数 <var>name</var> の内容の文字数に置換する。変数が未定義なら 0
	になる。
	<dd><var>name</var> が特殊パラメータ * または @ の場合は、${#} に同じ。
	<dt>${<var>name</var>#<var>pat</var>}
	<dd>変数 <var>name</var> の内容が <var>pat</var> で始まっているなら、
	その部分を削除したものに置換する。<var>pat</var> は、ファイル名展開と同様に
	<code>*</code>, <code>?</code>, <code>[</code> が特殊な意味を持つ。
	<code>*</code> に当てはまる文字数に複数の可能性がある場合、削除する部分が
	できるだけ短くなるようにする。
	<dt>${<var>name</var>##<var>pat</var>}
	<dd>${<var>name</var>#<var>pat</var>} とほぼ同じで、当てはまる文字数に
	複数の可能性がある場合に削除する部分ができるだけ長くなるようにする点だけが
	異なる。
	<dt>${<var>name</var>%<var>pat</var>}
	<dt>${<var>name</var>%%<var>pat</var>}
	<dd>${<var>name</var>#<var>pat</var>}, ${<var>name</var>##<var>pat</var>}
	とほぼ同じで、変数の内容の始めの部分ではなく末尾の部分を削除する点だけが
	異なる。
</dl>
<p>以下の名前の特殊パラメータが実装済である。
<dl>
	<dt>*, @
	<dd>全ての位置パラメータに展開する。
	<dd>引用符の中でこのパラメータが展開されるとき、@ では位置パラメータごとに
	単語分割を行う。* では他のパラメータに同じく、単語分割はしない
	(各位置パラメータは IFS 変数の最初の文字で区切られる)。
	引用符の外では、* も @ も同じである。
	<dt>#
	<dd>位置パラメータの個数を表す十進数に展開する。
	<dt>?
	<dd>最後に実行したコマンドの終了コードを表す十進数に展開する。
	コマンドがシグナルによって終了した場合は、(シグナル番号 + 384) となる。
	<code>kill -l $?</code> を実行すると実際のシグナル名が分かる。
	<!--<dt>-
	<dd>現在有効なシェルオプションを表す文字列に展開する。-->
	<dt>$
	<dd>このシェルのプロセス番号を表す十進数に展開する。サブシェル内では
	元のシェルのプロセス番号となる。
	<dt>!
	<dd>最後に起動したバックグラウンドジョブのプロセス番号を表す十進数に展開
	する。ジョブがパイプになっている場合はパイプ内の最後のプロセス番号となる。
	ジョブが <code>&amp;&amp;</code> または <code>||</code> による条件付き実行を
	指示されている場合など、サブシェル環境で実行される場合は、サブシェルの
	プロセス番号となる。
	<dt>0
	<dd>シェルを起動する際にコマンドライン引数でシェルスクリプトファイルを与えて
	シェルスクリプトを実行させているときは、そのシェルスクリプトのファイル名に
	展開する。対話的シェルではシェルを起動するときに与えられた実行ファイル名に
	展開する。
</dl>

<h2 id=jobcontrol>ジョブ制御</h2>
<p>パイプラインでつながった一連のコマンド群をジョブという。ジョブは
ジョブ番号とプロセスグループ ID を持つ。プロセスグループ ID
はジョブ内の最初のコマンドのプロセス ID に等しく、ジョブ内の全てのプロセスは
そのプロセスグループに属する。ジョブ番号とプロセスグループ ID は jobs
組込みコマンドで確認できる。
<p>対話的モードでは、端末からコマンドを読み取る前に自動的に <code>jobs -n</code>
コマンドが実行され、ジョブの状態に変化があれば報告する。

<h2 id=builtincommands>組込みコマンド</h2>
<p>組込みコマンドは以下の通り:
<dl>
	<dt>:
	<dt>true
	<dd>何もしない。(終了ステータスは 0)
	<dt>false
	<dd>何もしない。(終了ステータスは 1)
	<dt>exit
	<dd>シェルを終了する。-f オプションを付けない場合、
	未了のジョブが残っていれば警告を表示し、終了しない。
	<dt>logout
	<dd>exit と同様だが、ログインシェルとして実行されているときしか使えない。
	<dt>kill
	<dd>プロセス (グループ) にシグナルを送る。-s <var>signal</var>
	オプションで送信するシグナルを指定する。省略すると -s TERM とみなす。
	引数としてシグナルを送るプロセスの ID を指定する。
	プロセスグループに属する全てのプロセスにシグナルを送るには、プロセスグループ
	ID に負号 - を付けたものを引数として指定する。引数に <code>%</code>
	を付けると、プロセス ID の代わりにジョブ番号を指定できる。<!--
	外部コマンドがあるのに kill 内部コマンドが実装されている理由は以下の通り。
	<ul>
		<li>kill システムコールを使う練習
		<li>外部コマンドでは引数にジョブ番号を指定できない。
		<li>システムリソースを使い果たして fork すらできない状況に陥ったとき、
		外部コマンドの kill は実行できないが内部コマンドの kill なら実行できる。
	</ul>--><!--最後の二つは bash のマニュアルの受け売りである。-->
	<dt>wait
	<dd>ジョブの終了又は停止を待つ。引数を指定しないと、全ジョブを待つ。
	wait %1 のようにしてジョブ番号を指定すると、そのジョブを待つ。
	wait 1234 のようにしてプロセス ID を指定すると、そのプロセスが属する
	ジョブを待つ。
	<dd>このコマンドを中止するには Ctrl-C を押して SIGINT シグナルを送ればよい。
	<dt>suspend
	<dd>シェルをサスペンドする (シェル自身に SIGSTOP シグナルを送る)。
	ログインシェルとして実行されている場合、-f
	オプションを付けないと警告を表示し、サスペンドしない。
	<dt>jobs
	<dd>ジョブの一覧を表示する。-n オプションを付けると、
	最近に実行状況が変化したジョブのみ表示する。-l オプションを付けるとジョブの
	各プロセスのプロセス ID も表示する。
	引数にジョブ番号を指定するとその番号のジョブのみ表示する。
	<dt>disown
	<dd>ジョブのプロセスを終了しないままジョブの登録を抹消する。
	-a オプションを付けるか何もジョブを指定しないと、全てのジョブを対象とする。
	-r オプションを付けると、実行中のジョブのみを対象とする。
	-h オプションを付けると、登録を抹消するのではなく SIGHUP
	の再送を行わないようにする。(→<a href="#signals">シグナル</a>)
	<dt>fg
	<dt>bg
	<dd>ジョブをフォアグラウンド (fg) またはバックグラウンド (bg)
	で実行を再開する。ジョブ番号を引数として指定する。
	省略すると最後に使ったジョブ (カレントジョブ) を再開する。
	カレントジョブがないときはジョブ番号が最も大きいジョブを選択する。
	<dt>exec
	<dd>このシェルのプロセスを引数として指定したコマンドで置き換える。-f
	オプションを付けない場合、未了のジョブが残っていれば警告を表示し、
	プロセスは置き換えない。
	-c オプションを指定すると、新しいコマンドは環境変数なしで実行される。(-c
	オプションなしでは、新しいコマンドはシェルの環境変数を受け継ぐ)
	-l オプションを指定すると、コマンドはログインシェルとして実行される。
	-a <var>NAME</var> オプションでコマンドの main 関数に渡される最初の引数
	(argv[0]) の値を指定できる。
	<dd>コマンドを何も指定しない場合、プロセスは置き換わらない。
	コマンドを指定せずにリダイレクトだけ指示すると、シェル自身のプロセス内で
	リダイレクトが開かれる。このリダイレクトは、今後シェルで起動する全ての
	コマンドに受け継がれる。
	<dd>exec コマンドはパイプラインの中で使っては効果がない。
	<dt>cd
	<dd>作業ディレクトリを変更する。引数を省略すると環境変数 HOME
	の値に変更する。このコマンドは、環境変数 PWD, SPWD, OLDPWD の値も変更する。
	PWD と SPWD には新しい作業ディレクトリのパスが入る。OLDPWD にはひとつ前の
	作業ディレクトリのパスが入る。
	<dt>umask
	<dd>umask を表示・変更する。引数なしだと umask を表示する。
	引数に八進数を指定するとそれに umask を変更する。
	<dt>export
	<dd>環境変数を設定する。引数に、<var>NAME</var>=<var>VALUE</var>
	の形式で環境変数の名前と値を指定する。-n
	オプションを付けて環境変数の名前だけ指定すると、その環境変数を削除する。
	<dd>このコマンドには環境変数を表示する機能はない。適宜 printenv
	外部コマンドなどを使用すること。
	<dd>なお、このシェルにはシェル変数は存在しない。
	<dt>.
	<dt>source
	<dd>引数に指定されたファイル名のファイルを読み込んで、
	中に書いてあるコマンドを実行する。
	<dt>history
	<dd>履歴を操作する。引数なしだと、現在残っている全ての履歴を表示する。
	数値を引数に指定すると、最近の履歴をその数だけ表示する。
	その他、以下のオプションによって各種操作が可能。
	<dl>
		<dt>-c<dd>履歴を全て削除する。
		<dt>-d <var>n</var><dd>履歴番号 <var>n</var> の履歴一件を削除する。
		<dt>-r <var>file</var><dd>指定したファイルから履歴を読み込む。
		<dt>-w <var>file</var><dd>指定したファイルに履歴を上書き保存する。
		<dt>-s <var>arg</var>...<dd><var>arg</var>... を履歴に追加する。
		この時、この history コマンド自身は履歴に残らない。
	</dl>
	-r/-w オプションでファイルを指定しないと、histfile
	オプションのファイルを使う。
	<dt>alias
	<dd>エイリアスを設定・表示する。エイリアスは alias <var>name</var>=<var
	>value</var> のようにして設定する。設定してあるエイリアスを表示するには、
	エイリアスの名前だけを引数に指定する。引数を一つも指定しないと全エイリアスを
	表示する。引数は一度にいくつでも指定できる。エイリアスを設定する際に -g
	オプションを指定すると、それはグローバルエイリアスとなる。
	グローバルエイリアスは、コマンド名に限らずコマンドライン上の任意の位置で
	置換される。
	<dt>unalias
	<dd>引数で指定した名前のエイリアスを削除する。
	引数を一つも指定しないと全エイリアスを削除する。
	<dt>option
	<dd>シェルのオプションを設定する。例えば option histsize 300 とすると
	histsize オプションの値が 300 に設定される。-d オプションを用いて option
	-d histsize のようにすると、オプション設定がデフォルトに戻る。値を指定せずに
	option histsize のようにすると、オプションの現在値を表示する。
	<dd>設定できるオプションは以下の通り:
	<dl>
		<dt>histsize
		<dd>シェルが記憶するコマンド履歴の数 (デフォルト: 500)
		<dt>histfile
		<dd>コマンド履歴を保存するファイル名 (デフォルト: なし)
		<dt>histfilesize
		<dd>ファイルに保存するコマンド履歴の数 (デフォルト: 500)
		<dt>ps1
		<dd>コマンドを入力するときのプロンプト
		<dt>promptcommand
		<dd>毎回プロンプトを出す前に自動的に実行するコマンド
		<dt>huponexit
		<dd>yes なら、シェルの終了時に全てのジョブに SIGHUP シグナルを送る。
		(デフォルト: no)
	</dl>
	<dd>このコマンドは将来廃止予定である。
</dl>
<p>組込みコマンドは基本的にシェルのプロセス内でそのまま実行するが、
パイプラインや <code>&amp;</code> 記号を使ったときはサブシェル内で実行する。
この場合、一部の組込みコマンドは期待した働きをしないことがあるだろう。

<h2 id=signals>シグナル</h2>
<p>このシェルは、状況にかかわらず SIGQUIT, SIGTERM, SIGTSTP, SIGTTIN, SIGTTOU
シグナルを常に無視する。wait 組込みコマンド実行中以外は、SIGINT も無視する。
<p>シェルが SIGHUP を受け取ると、全てのジョブに対して SIGHUP を転送する。
停止しているジョブには SIGCONT も送る。その後シェル自身に SIGHUP
を送り直して自滅する。

<address>magicant (magica&#x6e;t&#46;sta&#x72;men&#0064;nifty&#46;com)</address>
