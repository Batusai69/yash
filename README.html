<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"> 
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>Yash 0.11 説明書</title>

<h1>Yash: yet another shell</h1>

<h2 id=abstract>概要</h2>
<p>このプログラムは C 言語で書いた簡単なコマンドライン端末用シェルである。
<p>これはもともと筆者が学科の課題で作ったプログラムであり、bash などの本格的な
シェルを目指して作ったものではない。機能は少なくシェルスクリプトすら未対応で、
バグも多いと思われる。しかし<q>シェルのソースを見てみたいが bash
のソースは複雑過ぎて読めない</q>というような人にとっては参考になるかもしれない。
<p>筆者は今後このプログラムのメンテナンスを積極的には行わないし、今後大きな
機能の追加の予定もない。
不具合の報告や機能改善の提案などは一応受け付けるが、期待しないこと。
<strong>なお、筆者はこのプログラムの動作に関して保証をしないし、
一切責任をとらない。もし使いたいのであればそれを承知の上で
すべて自己責任で使うこと。</strong>
<p>このプログラムは <a href="http://www.gnu.org/licenses/gpl.html">GNU General
Public License</a> (Version 2) の元で自由に再配布・変更などができる。
<!-- というか、GNU Readline ライブラリを使っている以上そうせざるを得ない -->
<p>なお、yash という名前のシェルは他にも存在すると思われるが、特に関係はない。

<h2 id=requirements>要件</h2>
<p>プログラムの中核部分は多くの Unix システムに共通のコードであるが、
付随的機能の実装に Linux 特有の機能を使用している。従って、このシェルを
コンパイル・実行できるのは Linux だけだろう。
<p>このプログラムをコンパイル・実行するには以下のものが必要である:
<ul>
	<li>Linux 2.6.16 以降
	<li>GNU make
	<li>GNU Complier Collection (GCC)
	<li>GNU Readline Library
</ul>
<p>また、ファイル名 <code>/dev/fd/<var>n</var></code> によってそのプロセスが
開いているファイルディスクリプタにアクセスできるようになっている必要がある。

<h2 id=compilation>コンパイル</h2>
<p>yash をコンパイルするには単に make を実行するだけである。
添付の Makefile には install ルールは定義していないので、
もしインストールする場合は /usr/local/bin 辺りに手動でコピーすること。
<p>Readline ライブラリのリンクに関するエラーが出る場合は、Makefile の LDFLAGS
変数の設定で -ltermcap を -lncurses や -lcurses に変えてやってみると
うまくゆくかもしれない。環境によっては -ltermcap
がなくてもうまくいくかもしれない。

<h2 id=firststep>基本的な動作</h2>
<p>プログラムを引数なしで起動すると、端末から一行ずつコマンドを読み取って
実行する対話的モードに入る。コマンドを入力すると、コマンドが実行され、
コマンドが終了すれば次のコマンドの入力を待つ。exit/logout コマンドを実行するか
EOL (Ctrl-D) を入力すると、(未了のジョブがなければ) シェルを終了する。
<p>シェルがログインシェルとして起動される (-l オプション付きで起動するか、
起動時のプログラム名が <code>-</code> で始まる) と、--noprofile オプションが
ない限り、対話的モードに入る前に初期化ファイル ~/.yash_profile を読み取って、
ファイルの中に書いてあるコマンドを一行ずつ実行する。ログインシェルでない場合、
--norc オプションがない限り、対話的モードに入る前に ~/.yashrc
を読み取って同様に実行する。この時実行するファイルは --rcfile
<var>filename</var> オプションで変更できる。
<p>起動時には、これらの他に次のオプションを指定できる:
<dl>
	<dt>--help
	<dd>ヘルプを表示して終了する
	<dt>-v, --version
	<dd>バージョン情報を表示して終了する
	<dt>-l, --login
	<dd>ログインシェルとして実行する。一部のコマンドの動作に影響する。
	<dt>-i, --interactive
	<dd>対話的モードを行う
	<dt>-c <var>command</var>
	<dd>コマンド <var>command</var> を実行して終了する。-i
	オプションより優先する。
</dl>
<p>対話的モードでのコマンドの読み取りは、GNU Readline ライブラリを用いている。
よって、大体 bash と同じように操作できる。option コマンドで履歴ファイルを
指定しておくと、シェルを起動・終了するときに履歴をファイルから読込み・保存する。
<p>対話的モードでは、シェルのプロセスグループ ID はシェル自身のプロセス ID
にリセットされる。シェルが終了するとき、元のプロセスグループ ID に戻る。
<p>対話的モードで毎回入力の読み取りに入る前に、コマンド <code>stty -inlcr -igncr
icrnl icanon echo echoe echok</code> の実行と同様にして端末がリセットされる。

<h2 id=commandsyntax>コマンドの文法</h2>
<p>コマンドの書式も大体 bash と同じであり、以下の記法 (記号) が使える:
<dl>
	<dt><var>n</var>><var>file</var>
	<dd>ファイルディスクリプタ <var>n</var> に、ファイル <var>file</var>
	に書き込むためのリダイレクトを生成する。<var>n</var>
	を省略すると標準出力をリダイレクトする。
	<dt><var>n</var>&lt;<var>file</var>
	<dd>ファイルディスクリプタ <var>n</var> に、ファイル <var>file</var>
	から読み込むためのリダイレクトを生成する。<var>n</var>
	を省略すると標準入力をリダイレクトする。
	<dt><var>n</var>&lt;><var>file</var>
	<dd>ファイルディスクリプタ <var>n</var> に、ファイル <var>file</var>
	に対する読み書き両用のリダイレクトを生成する。<var>n</var>
	を省略すると標準入力をリダイレクトする。
	<dt><var>n</var>>&lt;
	<dd>ファイルディスクリプタ <var>n</var> を閉じる。<var>n</var>
	を省略すると標準出力を閉じる。
	<dt><code>|</code>
	<dd>コマンドをパイプラインでつなぐ。
	前のコマンドの出力を次のコマンドに入力する。
	<dt><code>;</code>
	<dd>コマンドを順次実行する。前のコマンドが終わったら次のコマンドを実行する。
	<dt><code>&amp;</code>
	<dd><code>&amp;</code> の前に書かれたコマンドをバックグラウンドで起動する。
	<dt><code>&amp;&amp;</code>
	<dd><code>&amp;&amp;</code> の前に書かれたコマンドの終了ステータスが 0
	の時のみ次のコマンドを実行する
	<dt><code>||</code>
	<dd><code>||</code> の前に書かれたコマンドの終了ステータスが 0
	でない時のみ次のコマンドを実行する
	<dt><code>( ... )</code>
	<dd>括弧内のコマンドをサブシェルで実行する。
	<dt><code>#</code>
	<dd>これ以降をコメントとして無視する
</dl>
<p>リダイレクトの処理はパイプラインよりも後に行う。よって、リダイレクトと
パイプラインの指定が重複するときはリダイレクトがパイプラインを上書きする。
リダイレクトの指定で、ファイル名として <code>&amp;</code> に数字を続けたものを
指定すると、その数字のファイルディスクリプタを指定したものとみなす。
<p>演算子 <code>;</code>, <code>&amp;</code>, <code>&amp;&amp;</code>, <code
>||</code> の優先順位は全て同じになっている (これは bash などの他のシェルとは
異なる)。従って、<code>&amp;</code> と <code>&amp;&amp;</code> を組み合わせる
場合などは括弧 <code>( )</code> で優先順位を明示しなければならない。
パイプライン演算子 <code>|</code> の優先順位はこれらよりも高くなっている。
<p><code>|</code> でつないだパイプラインにおいて、最後のコマンドの後にも
<code>|</code> を指定すると (別のいい方をすると、<code>|</code> の後に
コマンドを書かないと)、最後のコマンドの出力が最初のコマンドの入力に繋がれ、
ループ状のパイプラインができる。
<p>括弧 <code>( )</code> で囲まれたコマンドはサブシェル (fork によって作られる、シェルの子プロセス) で実行される。
<p>コマンドは全て一行ずつ書かなくてはいけない。(行末にバックスラッシュを
置いたとしても) コマンドを複数行に分けて書くことはできない。
<p>変数は、環境変数のみ利用できる。パラメータ展開やコマンド置換などは (wordexp
ライブラリ関数のおかげで) ある程度利用できる。

<h2 id=jobcontrol>ジョブ制御</h2>
<p>パイプラインでつながった一連のコマンド群をジョブという。ジョブは
ジョブ番号とプロセスグループ ID を持つ。プロセスグループ ID
はジョブ内の最初のコマンドのプロセス ID に等しく、ジョブ内の全てのプロセスは
そのプロセスグループに属する。ジョブ番号とプロセスグループ ID は jobs
組込みコマンドで確認できる。
<p>対話的モードでは、端末からコマンドを読み取る前に自動的に jobs -n
コマンドが実行され、ジョブの状態に変化があれば報告する。

<h2 id=builtincommands>組込みコマンド</h2>
<p>組込みコマンドは以下の通り:
<dl>
	<dt>:
	<dd>何もしない。
	<dt>exit
	<dd>シェルを終了する。-f オプションを付けない場合、
	未了のジョブが残っていれば警告を表示し、終了しない。
	<dt>logout
	<dd>exit と同様だが、ログインシェルとして実行されているときしか使えない。
	<dt>kill
	<dd>プロセス (グループ) にシグナルを送る。-s <var>signal</var>
	オプションで送信するシグナルを指定する。省略すると -s TERM とみなす。
	引数としてシグナルを送るプロセスの ID を指定する。
	負数を指定するとその絶対値をプロセスグループの ID とみなす。引数に <code
	>%</code> を付けると、プロセス ID の代わりにジョブ番号を指定できる。<!--
	外部コマンドがあるのに kill 内部コマンドが実装されている理由は以下の通り。
	<ul>
		<li>kill システムコールを使う練習
		<li>外部コマンドでは引数にジョブ番号を指定できない。
		<li>システムリソースを使い果たして fork すらできない状況に陥ったとき、
		外部コマンドの kill は実行できないが内部コマンドの kill なら実行できる。
	</ul>--><!--最後の二つは bash のマニュアルの受け売りである。-->
	<dt>wait
	<dd>ジョブの終了又は停止を待つ。引数を指定しないと、全ジョブを待つ。
	wait %1 のようにしてジョブ番号を指定すると、そのジョブを待つ。
	wait 1234 のようにしてプロセス ID を指定すると、そのプロセスが属する
	ジョブを待つ。引数に指定できるジョブ番号・プロセス ID は一つまでである。
	<dd>このコマンドを中止するには Ctrl-C を押して SIGINT シグナルを送ればよい。
	<dt>suspend
	<dd>シェルをサスペンドする (シェル自身に SIGSTOP シグナルを送る)。
	ログインシェルとして実行されている場合、-f
	オプションを付けないと警告を表示し、サスペンドしない。
	<dt>jobs
	<dd>ジョブの一覧を表示する。-n オプションを付けると、
	最近に実行状況が変化したジョブのみ表示する。-l オプションを付けるとジョブの
	各プロセスのプロセス ID も表示する。
	引数にジョブ番号を指定するとその番号のジョブのみ表示する。
	<dt>disown
	<dd>ジョブのプロセスを終了しないままジョブの登録を抹消する。
	-a オプションを付けるか何もジョブを指定しないと、全てのジョブを対象とする。
	-r オプションを付けると、実行中のジョブのみを対象とする。
	-h オプションを付けると、登録を抹消するのではなく SIGHUP
	の再送を行わないようにする。(→<a href="#signals">シグナル</a>)
	<dt>fg
	<dt>bg
	<dd>ジョブをフォアグラウンド (fg) またはバックグラウンド (bg)
	で実行を再開する。ジョブ番号を引数として指定する。
	省略すると最後に使ったジョブ (カレントジョブ) を再開する。
	カレントジョブがないときはジョブ番号が最も大きいジョブを選択する。
	<dt>exec
	<dd>このシェルのプロセスを引数として指定したコマンドで置き換える。-f
	オプションを付けない場合、未了のジョブが残っていれば警告を表示し、
	プロセスは置き換えない。
	-c オプションを指定すると、新しいコマンドは環境変数なしで実行される。(-c
	オプションなしでは、新しいコマンドはシェルの環境変数を受け継ぐ)
	-l オプションを指定すると、コマンドはログインシェルとして実行される。
	-a <var>NAME</var> オプションでコマンドの main 関数に渡される最初の引数
	(argv[0]) の値を指定できる。
	<dd>コマンドを何も指定しない場合、プロセスは置き換わらない。
	コマンドを指定せずにリダイレクトだけ指示すると、シェル自身のプロセス内で
	リダイレクトが開かれる。このリダイレクトは、今後シェルで起動する全ての
	コマンドに受け継がれる。
	<dd>exec コマンドはパイプラインの中で使うことはできない。
	<dt>cd
	<dd>作業ディレクトリを変更する。引数を省略すると環境変数 HOME
	の値に変更する。このコマンドは、環境変数 PWD, SPWD, OLDPWD の値も変更する。
	PWD と SPWD には新しい作業ディレクトリのパスが入る。OLDPWD にはひとつ前の
	作業ディレクトリのパスが入る。
	<dt>umask
	<dd>umask を表示・変更する。引数なしだと umask を表示する。
	引数に八進数を指定するとそれに umask を変更する。
	<dt>export
	<dd>環境変数を設定する。引数に、<var>NAME</var>=<var>VALUE</var>
	の形式で環境変数の名前と値を指定する。-n
	オプションを付けて環境変数の名前だけ指定すると、その環境変数を削除する。
	<dd>このコマンドには環境変数を表示する機能はない。適宜 printenv
	外部コマンドなどを使用すること。
	<dd>なお、このシェルにはシェル変数は存在しない。
	<dt>.
	<dt>source
	<dd>引数に指定されたファイル名のファイルを読み込んで、
	中に書いてあるコマンドを実行する。
	<dt>history
	<dd>履歴を操作する。引数なしだと、現在残っている全ての履歴を表示する。
	数値を引数に指定すると、最近の履歴をその数だけ表示する。
	その他、以下のオプションによって各種操作が可能。
	<dl>
		<dt>-c<dd>履歴を全て削除する。
		<dt>-d <var>n</var><dd>履歴番号 <var>n</var> の履歴一件を削除する。
		<dt>-r <var>file</var><dd>指定したファイルから履歴を読み込む。
		<dt>-w <var>file</var><dd>指定したファイルに履歴を上書き保存する。
		<dt>-s <var>arg</var>...<dd><var>arg</var>... を履歴に追加する。
		この時、この history コマンド自身は履歴に残らない。
	</dl>
	-r/-w オプションでファイルを指定しないと、histfile
	オプションのファイルを使う。
	<dt>alias
	<dd>エイリアスを設定・表示する。エイリアスは alias <var>name</var>=<var
	>value</var> のようにして設定する。設定してあるエイリアスを表示するには、
	エイリアスの名前だけを引数に指定する。引数を一つも指定しないと全エイリアスを
	表示する。引数は一度に二つ以上指定できる。
	<dd>なお、エイリアスの展開は各コマンドに対して一度までしか行わない。
	<dt>unalias
	<dd>引数で指定した名前のエイリアスを削除する。
	引数を一つも指定しないと全エイリアスを削除する。
	<dt>option
	<dd>シェルのオプションを設定する。例えば option histsize 300 とすると
	histsize オプションの値が 300 に設定される。-d オプションを用いて option
	-d histsize のようにすると、オプション設定がデフォルトに戻る。値を指定せずに
	option histsize のようにすると、オプションの現在値を表示する。
	<dd>設定できるオプションは以下の通り:
	<dl>
		<dt>histsize
		<dd>シェルが記憶するコマンド履歴の数 (デフォルト: 500)
		<dt>histfile
		<dd>コマンド履歴を保存するファイル名 (デフォルト: なし)
		<dt>histfilesize
		<dd>ファイルに保存するコマンド履歴の数 (デフォルト: 500)
		<dt>ps1
		<dd>コマンドを入力するときのプロンプト
		<dt>promptcommand
		<dd>毎回プロンプトを出す前に自動的に実行するコマンド
		<dt>huponexit
		<dd>yes なら、シェルの終了時に全てのジョブに SIGHUP シグナルを送る。
		(デフォルト: no)
	</dl>
</dl>
<p>組込みコマンドは基本的にシェルのプロセス内でそのまま実行するが、
パイプラインや <code>&amp;</code> 記号を使ったときはサブシェル内で実行する。
この場合、一部の組込みコマンドは期待した働きをしないことがあるだろう。

<h2 id=signals>シグナル</h2>
<p>このシェルは、状況にかかわらず SIGQUIT, SIGTERM, SIGTSTP, SIGTTIN, SIGTTOU
シグナルを常に無視する。wait 組込みコマンド実行中以外は、SIGINT も無視する。
<p>シェルが SIGHUP を受け取ると、全てのジョブに対して SIGHUP を転送する。
停止しているジョブには SIGCONT も送る。その後シェル自身に SIGHUP
を送り直して自滅する。

<address>magicant (magica&#x6e;t&#46;sta&#x72;men&#0064;nifty&#46;com)</address>
